"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_v-money3_dist_v-money3_mjs"],{

/***/ "./node_modules/v-money3/dist/v-money3.mjs":
/*!*************************************************!*\
  !*** ./node_modules/v-money3/dist/v-money3.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BigNumber": () => (/* binding */ x),
/* harmony export */   "Money": () => (/* binding */ oe),
/* harmony export */   "Money3": () => (/* binding */ oe),
/* harmony export */   "Money3Component": () => (/* binding */ oe),
/* harmony export */   "Money3Directive": () => (/* binding */ P),
/* harmony export */   "VMoney": () => (/* binding */ P),
/* harmony export */   "VMoney3": () => (/* binding */ P),
/* harmony export */   "default": () => (/* binding */ fe),
/* harmony export */   "format": () => (/* binding */ k),
/* harmony export */   "unformat": () => (/* binding */ S)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
var L = Object.defineProperty;
var H = (t, e, n) => e in t ? L(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var w = (t, e, n) => (H(t, typeof e != "symbol" ? e + "" : e, n), n);

const M = ["+", "-"], $ = ["decimal", "thousands", "prefix", "suffix"];
function f(t) {
  return Math.max(0, Math.min(t, 1e3));
}
function y(t, e) {
  return t = t.padStart(e + 1, "0"), e === 0 ? t : `${t.slice(0, -e)}.${t.slice(-e)}`;
}
function V(t) {
  return t = t ? t.toString() : "", t.replace(/\D+/g, "") || "0";
}
function ie(t, e) {
  return t.replace(/(\d)(?=(?:\d{3})+\b)/gm, `$1${e}`);
}
function re(t, e, n) {
  return e ? t + n + e : t;
}
function h(t, e) {
  return M.includes(t) ? (console.warn(`v-money3 "${e}" property don't accept "${t}" as a value.`), !1) : /\d/g.test(t) ? (console.warn(`v-money3 "${e}" property don't accept "${t}" (any number) as a value.`), !1) : !0;
}
function ae(t) {
  for (const e of $)
    if (!h(t[e], e))
      return !1;
  return !0;
}
function N(t) {
  for (const e of $) {
    t[e] = t[e].replace(/\d+/g, "");
    for (const n of M)
      t[e] = t[e].replaceAll(n, "");
  }
  return t;
}
function F(t) {
  const e = t.length, n = t.indexOf(".");
  return e - (n + 1);
}
function C(t) {
  return t.replace(/^(-?)0+(?!\.)(.+)/, "$1$2");
}
function I(t) {
  return /^-?[\d]+$/g.test(t);
}
function O(t) {
  return /^-?[\d]+(\.[\d]+)$/g.test(t);
}
function R(t, e, n) {
  return e > t.length - 1 ? t : t.substring(0, e) + n + t.substring(e + 1);
}
function A(t, e) {
  const n = e - F(t);
  if (n >= 0)
    return t;
  let i = t.slice(0, n);
  const a = t.slice(n);
  if (i.charAt(i.length - 1) === "." && (i = i.slice(0, -1)), parseInt(a.charAt(0), 10) >= 5) {
    for (let s = i.length - 1; s >= 0; s -= 1) {
      const u = i.charAt(s);
      if (u !== "." && u !== "-") {
        const o = parseInt(u, 10) + 1;
        if (o < 10)
          return R(i, s, o);
        i = R(i, s, "0");
      }
    }
    return `1${i}`;
  }
  return i;
}
function se(t, e) {
  const n = () => {
    t.setSelectionRange(e, e);
  };
  t === document.activeElement && (n(), setTimeout(n, 1));
}
function D(t) {
  return new Event(t, { bubbles: !0, cancelable: !1 });
}
function r({ debug: t = !1 }, ...e) {
  t && console.log(...e);
}
const l = {
  debug: !1,
  masked: !1,
  prefix: "",
  suffix: "",
  thousands: ",",
  decimal: ".",
  precision: 2,
  disableNegative: !1,
  disabled: !1,
  min: null,
  max: null,
  allowBlank: !1,
  minimumNumberOfCharacters: 0,
  modelModifiers: {
    number: !1
  },
  shouldRound: !0
};
class x {
  constructor(e) {
    w(this, "number", 0n);
    w(this, "decimal", 0);
    this.setNumber(e);
  }
  getNumber() {
    return this.number;
  }
  getDecimalPrecision() {
    return this.decimal;
  }
  setNumber(e) {
    this.decimal = 0, typeof e == "bigint" ? this.number = e : typeof e == "number" ? this.setupString(e.toString()) : this.setupString(e);
  }
  toFixed(e = 0, n = !0) {
    let i = this.toString();
    const a = e - this.getDecimalPrecision();
    return a > 0 ? (i.includes(".") || (i += "."), i.padEnd(i.length + a, "0")) : a < 0 ? n ? A(i, e) : i.slice(0, a) : i;
  }
  toString() {
    let e = this.number.toString();
    if (this.decimal) {
      let n = !1;
      return e.charAt(0) === "-" && (e = e.substring(1), n = !0), e = e.padStart(e.length + this.decimal, "0"), e = `${e.slice(0, -this.decimal)}.${e.slice(-this.decimal)}`, e = C(e), (n ? "-" : "") + e;
    }
    return e;
  }
  lessThan(e) {
    const [n, i] = this.adjustComparisonNumbers(e);
    return n < i;
  }
  biggerThan(e) {
    const [n, i] = this.adjustComparisonNumbers(e);
    return n > i;
  }
  isEqual(e) {
    const [n, i] = this.adjustComparisonNumbers(e);
    return n === i;
  }
  setupString(e) {
    if (e = C(e), I(e))
      this.number = BigInt(e);
    else if (O(e))
      this.decimal = F(e), this.number = BigInt(e.replace(".", ""));
    else
      throw new Error(`BigNumber has received and invalid format for the constructor: ${e}`);
  }
  adjustComparisonNumbers(e) {
    let n;
    e.constructor.name !== "BigNumber" ? n = new x(e) : n = e;
    const i = this.getDecimalPrecision() - n.getDecimalPrecision();
    let a = this.getNumber(), s = n.getNumber();
    return i > 0 ? s = n.getNumber() * 10n ** BigInt(i) : i < 0 && (a = this.getNumber() * 10n ** BigInt(i * -1)), [a, s];
  }
}
function k(t, e = l, n = "") {
  if (r(e, "utils format() - caller", n), r(e, "utils format() - input1", t), t == null)
    t = "";
  else if (typeof t == "number")
    e.shouldRound ? t = t.toFixed(f(e.precision)) : t = t.toFixed(f(e.precision) + 1).slice(0, -1);
  else if (e.modelModifiers && e.modelModifiers.number && I(t))
    t = Number(t).toFixed(f(e.precision));
  else if (!e.disableNegative && t === "-")
    return t;
  r(e, "utils format() - input2", t);
  const i = e.disableNegative ? "" : t.indexOf("-") >= 0 ? "-" : "";
  let a = t.replace(e.prefix, "").replace(e.suffix, "");
  r(e, "utils format() - filtered", a), !e.precision && e.thousands !== "." && O(a) && (a = A(a, 0), r(e, "utils format() - !opt.precision && isValidFloat()", a));
  const s = V(a);
  r(e, "utils format() - numbers", s), r(e, "utils format() - numbersToCurrency", i + y(s, e.precision));
  const u = new x(i + y(s, e.precision));
  r(e, "utils format() - bigNumber1", u.toString()), e.max && u.biggerThan(e.max) && u.setNumber(e.max), e.min && u.lessThan(e.min) && u.setNumber(e.min);
  const o = u.toFixed(f(e.precision), e.shouldRound);
  if (r(e, "utils format() - bigNumber2", u.toFixed(f(e.precision))), /^0(\.0+)?$/g.test(o) && e.allowBlank)
    return "";
  let [c, m] = o.split(".");
  const p = m !== void 0 ? m.length : 0;
  c = c.padStart(e.minimumNumberOfCharacters - p, "0"), c = ie(c, e.thousands);
  const v = e.prefix + re(c, m, e.decimal) + e.suffix;
  return r(e, "utils format() - output", v), v;
}
function S(t, e = l, n = "") {
  if (r(e, "utils unformat() - caller", n), r(e, "utils unformat() - input", t), !e.disableNegative && t === "-")
    return r(e, "utils unformat() - return netagive symbol", t), t;
  const i = e.disableNegative ? "" : t.indexOf("-") >= 0 ? "-" : "", a = t.replace(e.prefix, "").replace(e.suffix, "");
  r(e, "utils unformat() - filtered", a);
  const s = V(a);
  r(e, "utils unformat() - numbers", s);
  const u = new x(i + y(s, e.precision));
  r(e, "utils unformat() - bigNumber1", s.toString()), e.max && u.biggerThan(e.max) && u.setNumber(e.max), e.min && u.lessThan(e.min) && u.setNumber(e.min);
  let o = u.toFixed(f(e.precision), e.shouldRound);
  return e.modelModifiers && e.modelModifiers.number && (o = parseFloat(o)), r(e, "utils unformat() - output", o), o;
}
const B = (t, e, n) => {
  if (r(e, "directive setValue() - caller", n), !ae(e)) {
    r(e, "directive setValue() - validateRestrictedOptions() return false. Stopping here...", t.value);
    return;
  }
  let i = t.value.length - (t.selectionEnd || 0);
  t.value = k(t.value, e, n), i = Math.max(i, e.suffix.length), i = t.value.length - i, i = Math.max(i, e.prefix.length), se(t, i), t.dispatchEvent(D("change"));
}, T = (t, e) => {
  const n = t.currentTarget, i = t.code === "Backspace" || t.code === "Delete", a = n.value.length - (n.selectionEnd || 0) === 0;
  if (r(e, "directive onkeydown() - el.value", n.value), r(e, "directive onkeydown() - backspacePressed", i), r(e, "directive onkeydown() - isAtEndPosition", a), e.allowBlank && i && a && S(n.value, e, "directive onkeydown allowBlank") === 0 && (r(e, 'directive onkeydown() - set el.value = ""', n.value), n.value = "", n.dispatchEvent(D("change"))), r(e, "directive onkeydown() - e.key", t.key), t.key === "+") {
    r(e, "directive onkeydown() - unformat el.value", n.value);
    let s = S(n.value, e, "directive onkeydown +");
    typeof s == "string" && (s = parseFloat(s)), s < 0 && (n.value = String(s * -1));
  }
}, E = (t, e) => {
  const n = t.currentTarget;
  r(e, "directive oninput()", n.value), /^[1-9]$/.test(n.value) && (n.value = y(n.value, f(e.precision)), r(e, "directive oninput() - is 1-9", n.value)), B(n, e, "directive oninput");
}, P = {
  mounted(t, e) {
    if (!e.value)
      return;
    const n = N({ ...l, ...e.value });
    if (r(n, "directive mounted() - opt", n), t.tagName.toLocaleUpperCase() !== "INPUT") {
      const i = t.getElementsByTagName("input");
      i.length !== 1 || (t = i[0]);
    }
    t.onkeydown = (i) => {
      T(i, n);
    }, t.oninput = (i) => {
      E(i, n);
    }, r(n, "directive mounted() - el.value", t.value), B(t, n, "directive mounted");
  },
  updated(t, e) {
    if (!e.value)
      return;
    const n = N({ ...l, ...e.value });
    t.onkeydown = (i) => {
      T(i, n);
    }, t.oninput = (i) => {
      E(i, n);
    }, r(n, "directive updated() - el.value", t.value), r(n, "directive updated() - opt", n), B(t, n, "directive updated");
  },
  beforeUnmount(t) {
    t.onkeydown = null, t.oninput = null, t.onfocus = null;
  }
}, ue = ["id", "value", "disabled"], le = {
  inheritAttrs: !1,
  name: "Money3",
  directives: {
    money3: P
  }
}, oe = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  ...le,
  props: {
    debug: {
      required: !1,
      type: Boolean,
      default: !1
    },
    id: {
      required: !1,
      type: [Number, String],
      default: () => {
        const t = (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        return t ? t.uid : null;
      }
    },
    modelValue: {
      required: !0,
      type: [Number, String]
    },
    modelModifiers: {
      required: !1,
      type: Object,
      default: () => ({ number: !1 })
    },
    masked: {
      type: Boolean,
      default: !1
    },
    precision: {
      type: Number,
      default: () => l.precision
    },
    decimal: {
      type: String,
      default: () => l.decimal,
      validator(t) {
        return h(t, "decimal");
      }
    },
    thousands: {
      type: String,
      default: () => l.thousands,
      validator(t) {
        return h(t, "thousands");
      }
    },
    prefix: {
      type: String,
      default: () => l.prefix,
      validator(t) {
        return h(t, "prefix");
      }
    },
    suffix: {
      type: String,
      default: () => l.suffix,
      validator(t) {
        return h(t, "suffix");
      }
    },
    disableNegative: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    max: {
      type: [Number, String],
      default: () => l.max
    },
    min: {
      type: [Number, String],
      default: () => l.min
    },
    allowBlank: {
      type: Boolean,
      default: () => l.allowBlank
    },
    minimumNumberOfCharacters: {
      type: Number,
      default: () => l.minimumNumberOfCharacters
    },
    shouldRound: {
      type: Boolean,
      default: () => l.shouldRound
    }
  },
  emits: ["update:model-value"],
  setup(t, { emit: e }) {
    const n = t, { modelValue: i, modelModifiers: a, masked: s, precision: u, shouldRound: o } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(n);
    r(n, "component setup()", n);
    let c = i.value;
    (n.disableNegative || c !== "-") && a.value && a.value.number && (o.value ? c = Number(i.value).toFixed(f(u.value)) : c = Number(i.value).toFixed(f(u.value) + 1).slice(0, -1));
    const m = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(k(c, n, "component setup"));
    r(n, "component setup() - data.formattedValue", m.value), (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(i, p);
    function p(g) {
      r(n, "component watch() -> value", g);
      const d = k(
        g,
        N({ ...n }),
        "component watch"
      );
      d !== m.value && (r(n, "component watch() changed -> formatted", d), m.value = d);
    }
    let v = null;
    function _(g) {
      let d = g.target.value;
      r(n, "component change() -> evt.target.value", d), s.value && !a.value.number || (d = S(
        d,
        N({ ...n }),
        "component change"
      )), d !== v && (v = d, r(n, "component change() -> update:model-value", d), e("update:model-value", d));
    }
    const j = (0,vue__WEBPACK_IMPORTED_MODULE_0__.useAttrs)(), q = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const g = {
        ...j
      };
      return delete g["onUpdate:modelValue"], g;
    });
    return (g, d) => {
      const U = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDirective)("money3");
      return (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)(((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("input", (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
        id: `${t.id}`
      }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(q), {
        type: "tel",
        class: "v-money3",
        value: m.value,
        disabled: n.disabled,
        onChange: _
      }), null, 16, ue)), [
        [U, {
          precision: (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(u),
          decimal: n.decimal,
          thousands: n.thousands,
          prefix: n.prefix,
          suffix: n.suffix,
          disableNegative: n.disableNegative,
          min: n.min,
          max: n.max,
          allowBlank: n.allowBlank,
          minimumNumberOfCharacters: n.minimumNumberOfCharacters,
          debug: n.debug,
          modelModifiers: (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(a),
          shouldRound: (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(o)
        }]
      ]);
    };
  }
}), fe = {
  install(t) {
    t.component("money3", oe), t.directive("money3", P);
  }
};



/***/ })

}]);